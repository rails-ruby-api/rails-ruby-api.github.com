<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>databases.rake</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            databases.rake
        </h1>
        <ul class="files">
            
            <li>
                activerecord/lib/active_record/railties/databases.rake
                
                    <a href="https://github.com/rails/rails/blob/4b7773683329f54c9e55baad81764b5b93e003d3/activerecord/lib/active_record/railties/databases.rake" target="_blank" class="github_url">on GitHub</a>
                
            </li>
            <li>Last modified: 2016-05-19 14:28:33 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>require &#39;active_record&#39;</p>

<p>db_namespace = namespace :db do</p>

<pre><code>task :load_config do
  ActiveRecord::Base.configurations       = ActiveRecord::Tasks::DatabaseTasks.database_configuration || {}
  ActiveRecord::Migrator.migrations_paths = ActiveRecord::Tasks::DatabaseTasks.migrations_paths
end

namespace :create do
  task :all =&gt; :load_config do
    ActiveRecord::Tasks::DatabaseTasks.create_all
  end
end

desc &#39;Creates the database from DATABASE_URL or config/database.yml for the current RAILS_ENV (use db:create:all to create all databases in the config). Without RAILS_ENV it defaults to creating the development and test databases.&#39;
task :create =&gt; [:load_config] do
  ActiveRecord::Tasks::DatabaseTasks.create_current
end

namespace :drop do
  task :all =&gt; :load_config do
    ActiveRecord::Tasks::DatabaseTasks.drop_all
  end
end

desc &#39;Drops the database from DATABASE_URL or config/database.yml for the current RAILS_ENV (use db:drop:all to drop all databases in the config). Without RAILS_ENV it defaults to dropping the development and test databases.&#39;
task :drop =&gt; [:load_config] do
  ActiveRecord::Tasks::DatabaseTasks.drop_current
end

namespace :purge do
  task :all =&gt; :load_config do
    ActiveRecord::Tasks::DatabaseTasks.purge_all
  end
end

# desc &quot;Empty the database from DATABASE_URL or config/database.yml for the current RAILS_ENV (use db:drop:all to drop all databases in the config). Without RAILS_ENV it defaults to purging the development and test databases.&quot;
task :purge =&gt; [:load_config] do
  ActiveRecord::Tasks::DatabaseTasks.purge_current
end

desc &quot;Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog).&quot;
task :migrate =&gt; [:environment, :load_config] do
  ActiveRecord::Tasks::DatabaseTasks.migrate
  db_namespace[&#39;_dump&#39;].invoke
end

# IMPORTANT: This task won&#39;t dump the schema if ActiveRecord::Base.dump_schema_after_migration is set to false
task :_dump do
  if ActiveRecord::Base.dump_schema_after_migration
    case ActiveRecord::Base.schema_format
    when :ruby then db_namespace[&quot;schema:dump&quot;].invoke
    when :sql  then db_namespace[&quot;structure:dump&quot;].invoke
    else
      raise &quot;unknown schema format #{ActiveRecord::Base.schema_format}&quot;
    end
  end
  # Allow this task to be called as many times as required. An example is the
  # migrate:redo task, which calls other two internally that depend on this one.
  db_namespace[&#39;_dump&#39;].reenable
end

namespace :migrate do
  # desc  &#39;Rollbacks the database one migration and re migrate up (options: STEP=x, VERSION=x).&#39;
  task :redo =&gt; [:environment, :load_config] do
    if ENV[&#39;VERSION&#39;]
      db_namespace[&#39;migrate:down&#39;].invoke
      db_namespace[&#39;migrate:up&#39;].invoke
    else
      db_namespace[&#39;rollback&#39;].invoke
      db_namespace[&#39;migrate&#39;].invoke
    end
  end

  # desc &#39;Resets your database using your migrations for the current environment&#39;
  task :reset =&gt; [&#39;db:drop&#39;, &#39;db:create&#39;, &#39;db:migrate&#39;]

  # desc &#39;Runs the &quot;up&quot; for a given migration VERSION.&#39;
  task :up =&gt; [:environment, :load_config] do
    version = ENV[&#39;VERSION&#39;] ? ENV[&#39;VERSION&#39;].to_i : nil
    raise &#39;VERSION is required&#39; unless version
    ActiveRecord::Migrator.run(:up, ActiveRecord::Migrator.migrations_paths, version)
    db_namespace[&#39;_dump&#39;].invoke
  end

  # desc &#39;Runs the &quot;down&quot; for a given migration VERSION.&#39;
  task :down =&gt; [:environment, :load_config] do
    version = ENV[&#39;VERSION&#39;] ? ENV[&#39;VERSION&#39;].to_i : nil
    raise &#39;VERSION is required - To go down one migration, run db:rollback&#39; unless version
    ActiveRecord::Migrator.run(:down, ActiveRecord::Migrator.migrations_paths, version)
    db_namespace[&#39;_dump&#39;].invoke
  end

  desc &#39;Display status of migrations&#39;
  task :status =&gt; [:environment, :load_config] do
    unless ActiveRecord::SchemaMigration.table_exists?
      abort &#39;Schema migrations table does not exist yet.&#39;
    end
    db_list = ActiveRecord::SchemaMigration.normalized_versions

    file_list =
        ActiveRecord::Migrator.migrations_paths.flat_map do |path|
          # match &quot;20091231235959_some_name.rb&quot; and &quot;001_some_name.rb&quot; pattern
          Dir.foreach(path).grep(/^(\d{3,})_(.+)\.rb$/) do
            version = ActiveRecord::SchemaMigration.normalize_migration_number($1)
            status = db_list.delete(version) ? &#39;up&#39; : &#39;down&#39;
            [status, version, $2.humanize]
          end
        end

    db_list.map! do |version|
      [&#39;up&#39;, version, &#39;********** NO FILE **********&#39;]
    end
    # output
    puts &quot;\ndatabase: #{ActiveRecord::Base.connection_config[:database]}\n\n&quot;
    puts &quot;#{&#39;Status&#39;.center(8)}  #{&#39;Migration ID&#39;.ljust(14)}  Migration Name&quot;
    puts &quot;-&quot; * 50
    (db_list + file_list).sort_by { |_, version, _| version }.each do |status, version, name|
      puts &quot;#{status.center(8)}  #{version.ljust(14)}  #{name}&quot;
    end
    puts
  end
end

desc &#39;Rolls the schema back to the previous version (specify steps w/ STEP=n).&#39;
task :rollback =&gt; [:environment, :load_config] do
  step = ENV[&#39;STEP&#39;] ? ENV[&#39;STEP&#39;].to_i : 1
  ActiveRecord::Migrator.rollback(ActiveRecord::Migrator.migrations_paths, step)
  db_namespace[&#39;_dump&#39;].invoke
end

# desc &#39;Pushes the schema to the next version (specify steps w/ STEP=n).&#39;
task :forward =&gt; [:environment, :load_config] do
  step = ENV[&#39;STEP&#39;] ? ENV[&#39;STEP&#39;].to_i : 1
  ActiveRecord::Migrator.forward(ActiveRecord::Migrator.migrations_paths, step)
  db_namespace[&#39;_dump&#39;].invoke
end

# desc &#39;Drops and recreates the database from db/schema.rb for the current environment and loads the seeds.&#39;
task :reset =&gt; [:environment, :load_config] do
  db_namespace[&quot;drop&quot;].invoke
  db_namespace[&quot;setup&quot;].invoke
end

# desc &quot;Retrieves the charset for the current environment&#39;s database&quot;
task :charset =&gt; [:environment, :load_config] do
  puts ActiveRecord::Tasks::DatabaseTasks.charset_current
end

# desc &quot;Retrieves the collation for the current environment&#39;s database&quot;
task :collation =&gt; [:environment, :load_config] do
  begin
    puts ActiveRecord::Tasks::DatabaseTasks.collation_current
  rescue NoMethodError
    $stderr.puts &#39;Sorry, your database adapter is not supported yet. Feel free to submit a patch.&#39;
  end
end

desc &#39;Retrieves the current schema version number&#39;
task :version =&gt; [:environment, :load_config] do
  puts &quot;Current version: #{ActiveRecord::Migrator.current_version}&quot;
end

# desc &quot;Raises an error if there are pending migrations&quot;
task :abort_if_pending_migrations =&gt; :environment do
  pending_migrations = ActiveRecord::Migrator.open(ActiveRecord::Migrator.migrations_paths).pending_migrations

  if pending_migrations.any?
    puts &quot;You have #{pending_migrations.size} pending #{pending_migrations.size &gt; 1 ? &#39;migrations:&#39; : &#39;migration:&#39;}&quot;
    pending_migrations.each do |pending_migration|
      puts &#39;  %4d %s&#39; % [pending_migration.version, pending_migration.name]
    end
    abort %{Run `rake db:migrate` to update your database then try again.}
  end
end

desc &#39;Create the database, load the schema, and initialize with the seed data (use db:reset to also drop the database first)&#39;
task :setup =&gt; [&#39;db:schema:load_if_ruby&#39;, &#39;db:structure:load_if_sql&#39;, :seed]

desc &#39;Load the seed data from db/seeds.rb&#39;
task :seed do
  db_namespace[&#39;abort_if_pending_migrations&#39;].invoke
  ActiveRecord::Tasks::DatabaseTasks.load_seed
end

namespace :fixtures do
  desc &quot;Load fixtures into the current environment&#39;s database. Load specific fixtures using FIXTURES=x,y. Load from subdirectory in test/fixtures using FIXTURES_DIR=z. Specify an alternative path (eg. spec/fixtures) using FIXTURES_PATH=spec/fixtures.&quot;
  task :load =&gt; [:environment, :load_config] do
    require &#39;active_record/fixtures&#39;

    base_dir = ActiveRecord::Tasks::DatabaseTasks.fixtures_path

    fixtures_dir = if ENV[&#39;FIXTURES_DIR&#39;]
                     File.join base_dir, ENV[&#39;FIXTURES_DIR&#39;]
                   else
                     base_dir
                   end

    fixture_files = if ENV[&#39;FIXTURES&#39;]
                      ENV[&#39;FIXTURES&#39;].split(&#39;,&#39;)
                    else
                      # The use of String#[] here is to support namespaced fixtures
                      Dir[&quot;#{fixtures_dir}   /*.yml&quot;].map {|f| f[(fixtures_dir.size + 1)..-5] }
                    end

    ActiveRecord::FixtureSet.create_fixtures(fixtures_dir, fixture_files)
  end

  # desc &quot;Search for a fixture given a LABEL or ID. Specify an alternative path (eg. spec/fixtures) using FIXTURES_PATH=spec/fixtures.&quot;
  task :identify =&gt; [:environment, :load_config] do
    require &#39;active_record/fixtures&#39;

    label, id = ENV[&#39;LABEL&#39;], ENV[&#39;ID&#39;]
    raise &#39;LABEL or ID required&#39; if label.blank? &amp;&amp; id.blank?

    puts %Q(The fixture ID for &quot;#{label}&quot; is #{ActiveRecord::FixtureSet.identify(label)}.) if label

    base_dir = ActiveRecord::Tasks::DatabaseTasks.fixtures_path

    Dir[&quot;#{base_dir}/   *.yml&quot;].each do |file|
      if data = YAML::load(ERB.new(IO.read(file)).result)
        data.each_key do |key|
          key_id = ActiveRecord::FixtureSet.identify(key)

          if key == label || key_id == id.to_i
            puts &quot;#{file}: #{key} (#{key_id})&quot;
          end
        end
      end
    end
  end
end

namespace :schema do
  desc &#39;Create a db/schema.rb file that is portable against any DB supported by AR&#39;
  task :dump =&gt; [:environment, :load_config] do
    require &#39;active_record/schema_dumper&#39;
    filename = ENV[&#39;SCHEMA&#39;] || File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, &#39;schema.rb&#39;)
    File.open(filename, &quot;w:utf-8&quot;) do |file|
      ActiveRecord::SchemaDumper.dump(ActiveRecord::Base.connection, file)
    end
    db_namespace[&#39;schema:dump&#39;].reenable
  end

  desc &#39;Load a schema.rb file into the database&#39;
  task :load =&gt; [:environment, :load_config] do
    ActiveRecord::Tasks::DatabaseTasks.load_schema_current(:ruby, ENV[&#39;SCHEMA&#39;])
  end

  task :load_if_ruby =&gt; [&#39;db:create&#39;, :environment] do
    db_namespace[&quot;schema:load&quot;].invoke if ActiveRecord::Base.schema_format == :ruby
  end

  namespace :cache do
    desc &#39;Create a db/schema_cache.dump file.&#39;
    task :dump =&gt; [:environment, :load_config] do
      con = ActiveRecord::Base.connection
      filename = File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, &quot;schema_cache.dump&quot;)

      con.schema_cache.clear!
      con.tables.each { |table| con.schema_cache.add(table) }
      open(filename, &#39;wb&#39;) { |f| f.write(Marshal.dump(con.schema_cache)) }
    end

    desc &#39;Clear a db/schema_cache.dump file.&#39;
    task :clear =&gt; [:environment, :load_config] do
      filename = File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, &quot;schema_cache.dump&quot;)
      FileUtils.rm(filename) if File.exist?(filename)
    end
  end

end

namespace :structure do
  desc &#39;Dump the database structure to db/structure.sql. Specify another file with DB_STRUCTURE=db/my_structure.sql&#39;
  task :dump =&gt; [:environment, :load_config] do
    filename = ENV[&#39;DB_STRUCTURE&#39;] || File.join(ActiveRecord::Tasks::DatabaseTasks.db_dir, &quot;structure.sql&quot;)
    current_config = ActiveRecord::Tasks::DatabaseTasks.current_config
    ActiveRecord::Tasks::DatabaseTasks.structure_dump(current_config, filename)

    if ActiveRecord::Base.connection.supports_migrations? &amp;&amp;
        ActiveRecord::SchemaMigration.table_exists?
      File.open(filename, &quot;a&quot;) do |f|
        f.puts ActiveRecord::Base.connection.dump_schema_information
        f.print &quot;\n&quot;
      end
    end
    db_namespace[&#39;structure:dump&#39;].reenable
  end

  desc &quot;Recreate the databases from the structure.sql file&quot;
  task :load =&gt; [:load_config] do
    ActiveRecord::Tasks::DatabaseTasks.load_schema_current(:sql, ENV[&#39;DB_STRUCTURE&#39;])
  end

  task :load_if_sql =&gt; [&#39;db:create&#39;, :environment] do
    db_namespace[&quot;structure:load&quot;].invoke if ActiveRecord::Base.schema_format == :sql
  end
end

namespace :test do

  task :deprecated do
    Rake.application.top_level_tasks.grep(/^db:test:/).each do |task|
      $stderr.puts &quot;WARNING: #{task} is deprecated. The Rails test helper now maintains &quot; \
                   &quot;your test schema automatically, see the release notes for details.&quot;
    end
  end

  # desc &quot;Recreate the test database from the current schema&quot;
  task :load =&gt; %w(db:test:purge) do
    case ActiveRecord::Base.schema_format
      when :ruby
        db_namespace[&quot;test:load_schema&quot;].invoke
      when :sql
        db_namespace[&quot;test:load_structure&quot;].invoke
    end
  end

  # desc &quot;Recreate the test database from an existent schema.rb file&quot;
  task :load_schema =&gt; %w(db:test:purge) do
    begin
      should_reconnect = ActiveRecord::Base.connection_pool.active_connection?
      ActiveRecord::Schema.verbose = false
      ActiveRecord::Tasks::DatabaseTasks.load_schema_for ActiveRecord::Base.configurations[&#39;test&#39;], :ruby, ENV[&#39;SCHEMA&#39;]
    ensure
      if should_reconnect
        ActiveRecord::Base.establish_connection(ActiveRecord::Base.configurations[ActiveRecord::Tasks::DatabaseTasks.env])
      end
    end
  end

  # desc &quot;Recreate the test database from an existent structure.sql file&quot;
  task :load_structure =&gt; %w(db:test:purge) do
    ActiveRecord::Tasks::DatabaseTasks.load_schema_for ActiveRecord::Base.configurations[&#39;test&#39;], :sql, ENV[&#39;SCHEMA&#39;]
  end

  # desc &quot;Recreate the test database from a fresh schema&quot;
  task :clone =&gt; %w(db:test:deprecated environment) do
    case ActiveRecord::Base.schema_format
      when :ruby
        db_namespace[&quot;test:clone_schema&quot;].invoke
      when :sql
        db_namespace[&quot;test:clone_structure&quot;].invoke
    end
  end

  # desc &quot;Recreate the test database from a fresh schema.rb file&quot;
  task :clone_schema =&gt; %w(db:test:deprecated db:schema:dump db:test:load_schema)

  # desc &quot;Recreate the test database from a fresh structure.sql file&quot;
  task :clone_structure =&gt; %w(db:test:deprecated db:structure:dump db:test:load_structure)

  # desc &quot;Empty the test database&quot;
  task :purge =&gt; %w(environment load_config) do
    ActiveRecord::Tasks::DatabaseTasks.purge ActiveRecord::Base.configurations[&#39;test&#39;]
  end

  # desc &#39;Check for pending migrations and load the test schema&#39;
  task :prepare =&gt; %w(environment load_config) do
    unless ActiveRecord::Base.configurations.blank?
      db_namespace[&#39;test:load&#39;].invoke
    end
  end
end
</code></pre>

<p>end</p>

<p>namespace :railties do</p>

<pre><code>namespace :install do
  # desc &quot;Copies missing migrations from Railties (e.g. engines). You can specify Railties to use with FROM=railtie1,railtie2&quot;
  task :migrations =&gt; :&#39;db:load_config&#39; do
    to_load = ENV[&#39;FROM&#39;].blank? ? :all : ENV[&#39;FROM&#39;].split(&quot;,&quot;).map {|n| n.strip }
    railties = {}
    Rails.application.migration_railties.each do |railtie|
      next unless to_load == :all || to_load.include?(railtie.railtie_name)

      if railtie.respond_to?(:paths) &amp;&amp; (path = railtie.paths[&#39;db/migrate&#39;].first)
        railties[railtie.railtie_name] = path
      end
    end

    on_skip = Proc.new do |name, migration|
      puts &quot;NOTE: Migration #{migration.basename} from #{name} has been skipped. Migration with the same name already exists.&quot;
    end

    on_copy = Proc.new do |name, migration|
      puts &quot;Copied migration #{migration.basename} from #{name}&quot;
    end

    ActiveRecord::Migration.copy(ActiveRecord::Migrator.migrations_paths.first, railties,
                                  :on_skip =&gt; on_skip, :on_copy =&gt; on_copy)
  end
end
</code></pre>

<p>end</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>