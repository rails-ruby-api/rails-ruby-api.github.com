<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>Enumerable</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../css/github.css" type="text/css" media="screen" />
<script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            <span class="type">Module</span> 
            Enumerable 
            
        </h1>
        <ul class="files">
            
            <li><a href="../files/enum_c.html">enum.c</a></li>
            
            <li><a href="../files/enumerator_c.html">enumerator.c</a></li>
            
            <li><a href="../files/lib/set_rb.html">lib/set.rb</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>The <code>Enumerable</code> mixin provides collection classes with several
traversal and searching methods, and with the ability to sort. The class
must provide a method <code>each</code>, which yields successive members of
the collection. If <code>Enumerable#max</code>, <code>#min</code>, or
<code>#sort</code> is used, the objects in the collection must also
implement a meaningful <code>&lt;=&gt;</code> operator, as these methods
rely on an ordering between members of the collection.</p>

    </div>
  


  


  
  


  


  
    <!-- Method ref -->
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
      
        <dt>A</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-all-3F">all?</a>,
              </li>
            
              
              <li>
                <a href="#method-i-any-3F">any?</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>C</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-chunk">chunk</a>,
              </li>
            
              
              <li>
                <a href="#method-i-chunk_while">chunk_while</a>,
              </li>
            
              
              <li>
                <a href="#method-i-collect">collect</a>,
              </li>
            
              
              <li>
                <a href="#method-i-collect_concat">collect_concat</a>,
              </li>
            
              
              <li>
                <a href="#method-i-count">count</a>,
              </li>
            
              
              <li>
                <a href="#method-i-cycle">cycle</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>D</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-detect">detect</a>,
              </li>
            
              
              <li>
                <a href="#method-i-drop">drop</a>,
              </li>
            
              
              <li>
                <a href="#method-i-drop_while">drop_while</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>E</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-each_cons">each_cons</a>,
              </li>
            
              
              <li>
                <a href="#method-i-each_entry">each_entry</a>,
              </li>
            
              
              <li>
                <a href="#method-i-each_slice">each_slice</a>,
              </li>
            
              
              <li>
                <a href="#method-i-each_with_index">each_with_index</a>,
              </li>
            
              
              <li>
                <a href="#method-i-each_with_object">each_with_object</a>,
              </li>
            
              
              <li>
                <a href="#method-i-entries">entries</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>F</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-find">find</a>,
              </li>
            
              
              <li>
                <a href="#method-i-find_all">find_all</a>,
              </li>
            
              
              <li>
                <a href="#method-i-find_index">find_index</a>,
              </li>
            
              
              <li>
                <a href="#method-i-first">first</a>,
              </li>
            
              
              <li>
                <a href="#method-i-flat_map">flat_map</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>G</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-grep">grep</a>,
              </li>
            
              
              <li>
                <a href="#method-i-grep_v">grep_v</a>,
              </li>
            
              
              <li>
                <a href="#method-i-group_by">group_by</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>I</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-include-3F">include?</a>,
              </li>
            
              
              <li>
                <a href="#method-i-inject">inject</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>L</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-lazy">lazy</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>M</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-map">map</a>,
              </li>
            
              
              <li>
                <a href="#method-i-max">max</a>,
              </li>
            
              
              <li>
                <a href="#method-i-max_by">max_by</a>,
              </li>
            
              
              <li>
                <a href="#method-i-member-3F">member?</a>,
              </li>
            
              
              <li>
                <a href="#method-i-min">min</a>,
              </li>
            
              
              <li>
                <a href="#method-i-min_by">min_by</a>,
              </li>
            
              
              <li>
                <a href="#method-i-minmax">minmax</a>,
              </li>
            
              
              <li>
                <a href="#method-i-minmax_by">minmax_by</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>N</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-none-3F">none?</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>O</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-one-3F">one?</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>P</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-partition">partition</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>R</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-reduce">reduce</a>,
              </li>
            
              
              <li>
                <a href="#method-i-reject">reject</a>,
              </li>
            
              
              <li>
                <a href="#method-i-reverse_each">reverse_each</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>S</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-select">select</a>,
              </li>
            
              
              <li>
                <a href="#method-i-slice_after">slice_after</a>,
              </li>
            
              
              <li>
                <a href="#method-i-slice_before">slice_before</a>,
              </li>
            
              
              <li>
                <a href="#method-i-slice_when">slice_when</a>,
              </li>
            
              
              <li>
                <a href="#method-i-sort">sort</a>,
              </li>
            
              
              <li>
                <a href="#method-i-sort_by">sort_by</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>T</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-take">take</a>,
              </li>
            
              
              <li>
                <a href="#method-i-take_while">take_while</a>,
              </li>
            
              
              <li>
                <a href="#method-i-to_a">to_a</a>,
              </li>
            
              
              <li>
                <a href="#method-i-to_h">to_h</a>,
              </li>
            
              
              <li>
                <a href="#method-i-to_set">to_set</a>
              </li>
            
          </ul>
        </dd>
      
        <dt>Z</dt>
        <dd>
          <ul>
            
              
              <li>
                <a href="#method-i-zip">zip</a>
              </li>
            
          </ul>
        </dd>
      
    </dl>
  

  



  

    

    

    


    


    <!-- Methods -->
        
      <div class="sectiontitle">Instance Public methods</div>
      
        <div class="method">
          <div class="title method-title" id="method-i-all-3F">
            
              <b>enum.all? [{ |obj| block } ]   &rarr; true or false
</b>
            
            <a href="../classes/Enumerable.html#method-i-all-3F" name="method-i-all-3F" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block never returns <code>false</code> or
<code>nil</code>. If the block is not given, Ruby adds an implicit block of
<code>{ |obj| obj }</code> which will cause <a
href="Enumerable.html#method-i-all-3F">all?</a> to return <code>true</code>
when none of the collection members are <code>false</code> or
<code>nil</code>.</p>

<pre><code>%w[ant bear cat].all? { |word| word.length &gt;= 3 } #=&gt; true
%w[ant bear cat].all? { |word| word.length &gt;= 4 } #=&gt; false
[nil, true, 99].all?                              #=&gt; false
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-all-3F_source')" id="l_method-i-all-3F_source">show</a>
                
              </p>
              <div id="method-i-all-3F_source" class="dyn-source">
                <pre>static VALUE
enum_all(VALUE obj)
{
    struct MEMO *memo = MEMO_NEW(Qtrue, 0, 0);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(all), (VALUE)memo);
    return memo-&gt;v1;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-any-3F">
            
              <b>enum.any? [{ |obj| block }]   &rarr; true or false
</b>
            
            <a href="../classes/Enumerable.html#method-i-any-3F" name="method-i-any-3F" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block ever returns a value other than
<code>false</code> or <code>nil</code>. If the block is not given, Ruby
adds an implicit block of <code>{ |obj| obj }</code> that will cause <a
href="Enumerable.html#method-i-any-3F">any?</a> to return <code>true</code>
if at least one of the collection members is not <code>false</code> or
<code>nil</code>.</p>

<pre><code>%w[ant bear cat].any? { |word| word.length &gt;= 3 } #=&gt; true
%w[ant bear cat].any? { |word| word.length &gt;= 4 } #=&gt; true
[nil, true, 99].any?                              #=&gt; true
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-any-3F_source')" id="l_method-i-any-3F_source">show</a>
                
              </p>
              <div id="method-i-any-3F_source" class="dyn-source">
                <pre>static VALUE
enum_any(VALUE obj)
{
    struct MEMO *memo = MEMO_NEW(Qfalse, 0, 0);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(any), (VALUE)memo);
    return memo-&gt;v1;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-chunk">
            
              <b>enum.chunk { |elt| ... }                       &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-chunk" name="method-i-chunk" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Enumerates over the items, chunking them together based on the return value
of the block.</p>

<p>Consecutive elements which return the same block value are chunked
together.</p>

<p>For example, consecutive even numbers and odd numbers can be chunked as
follows.</p>

<pre><code>[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5].chunk { |n|
  n.even?
}.each { |even, ary|
  p [even, ary]
}
#=&gt; [false, [3, 1]]
#   [true, [4]]
#   [false, [1, 5, 9]]
#   [true, [2, 6]]
#   [false, [5, 3, 5]]
</code></pre>

<p>This method is especially useful for sorted series of elements. The
following example counts words for each initial letter.</p>

<pre><code>open(&quot;/usr/share/dict/words&quot;, &quot;r:iso-8859-1&quot;) { |f|
  f.chunk { |line| line.ord }.each { |ch, lines| p [ch.chr, lines.length] }
}
#=&gt; [&quot;\n&quot;, 1]
#   [&quot;A&quot;, 1327]
#   [&quot;B&quot;, 1372]
#   [&quot;C&quot;, 1507]
#   [&quot;D&quot;, 791]
#   ...
</code></pre>

<p>The following key values have special meaning:</p>
<ul><li>
<p><code>nil</code> and <code>:_separator</code> specifies that the elements
should be dropped.</p>
</li><li>
<p><code>:_alone</code> specifies that the element should be chunked by
itself.</p>
</li></ul>

<p>Any other symbols that begin with an underscore will raise an error:</p>

<pre><code>items.chunk { |item| :_underscore }
#=&gt; RuntimeError: symbols beginning with an underscore are reserved
</code></pre>

<p><code>nil</code> and <code>:_separator</code> can be used to ignore some
elements.</p>

<p>For example, the sequence of hyphens in svn log can be eliminated as
follows:</p>

<pre><code>sep = &quot;-&quot;*72 + &quot;\n&quot;
IO.popen(&quot;svn log README&quot;) { |f|
  f.chunk { |line|
    line != sep || nil
  }.each { |_, lines|
    pp lines
  }
}
#=&gt; [&quot;r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n&quot;,
#    &quot;\n&quot;,
#    &quot;* README, README.ja: Update the portability section.\n&quot;,
#    &quot;\n&quot;]
#   [&quot;r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n&quot;,
#    &quot;\n&quot;,
#    &quot;* README, README.ja: Add a note about default C flags.\n&quot;,
#    &quot;\n&quot;]
#   ...
</code></pre>

<p>Paragraphs separated by empty lines can be parsed as follows:</p>

<pre><code>File.foreach(&quot;README&quot;).chunk { |line|
  /\A\s*\z/ !~ line || nil
}.each { |_, lines|
  pp lines
}
</code></pre>

<p><code>:_alone</code> can be used to force items into their own chunk. For
example, you can put lines that contain a URL by themselves, and chunk the
rest of the lines together, like this:</p>

<pre><code>pattern = /http/
open(filename) { |f|
  f.chunk { |line| line =~ pattern ? :_alone : true }.each { |key, lines|
    pp lines
  }
}
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-chunk_source')" id="l_method-i-chunk_source">show</a>
                
              </p>
              <div id="method-i-chunk_source" class="dyn-source">
                <pre>static VALUE
enum_chunk(VALUE enumerable)
{
    VALUE enumerator;

    if (!rb_block_given_p())
        rb_raise(rb_eArgError, &quot;no block given&quot;);

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_enumerable&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_categorize&quot;), rb_block_proc());
    rb_block_call(enumerator, idInitialize, 0, 0, chunk_i, enumerator);
    return enumerator;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-chunk_while">
            
              <b>enum.chunk_while {|elt_before, elt_after| bool } &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-chunk_while" name="method-i-chunk_while" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Creates an enumerator for each chunked elements. The beginnings of chunks
are defined by the block.</p>

<p>This method split each chunk using adjacent elements, <em>elt_before</em>
and <em>elt_after</em>, in the receiver enumerator. This method split
chunks between <em>elt_before</em> and <em>elt_after</em> where the block
returns false.</p>

<p>The block is called the length of the receiver enumerator minus one.</p>

<p>The result enumerator yields the chunked elements as an array. So
<code>each</code> method can be called as follows:</p>

<pre><code>enum.chunk_while { |elt_before, elt_after| bool }.each { |ary| ... }</code></pre>

<p>Other methods of the <a href="Enumerator.html">Enumerator</a> class and <a
href="Enumerable.html">Enumerable</a> module, such as <code>to_a</code>,
<code>map</code>, etc., are also usable.</p>

<p>For example, one-by-one increasing subsequence can be chunked as follows:</p>

<pre><code>a = [1,2,4,9,10,11,12,15,16,19,20,21]
b = a.chunk_while {|i, j| i+1 == j }
p b.to_a #=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
c = b.map {|a| a.length &lt; 3 ? a : &quot;#{a.first}-#{a.last}&quot; }
p c #=&gt; [[1, 2], [4], &quot;9-12&quot;, [15, 16], &quot;19-21&quot;]
d = c.join(&quot;,&quot;)
p d #=&gt; &quot;1,2,4,9-12,15,16,19-21&quot;
</code></pre>

<p>Increasing (non-decreasing) subsequence can be chunked as follows:</p>

<pre><code>a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]
p a.chunk_while {|i, j| i &lt;= j }.to_a
#=&gt; [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]
</code></pre>

<p>Adjacent evens and odds can be chunked as follows: (Enumerable#chunk is
another way to do it.)</p>

<pre><code>a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]
p a.chunk_while {|i, j| i.even? == j.even? }.to_a
#=&gt; [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-chunk_while_source')" id="l_method-i-chunk_while_source">show</a>
                
              </p>
              <div id="method-i-chunk_while_source" class="dyn-source">
                <pre>static VALUE
enum_chunk_while(VALUE enumerable)
{
    VALUE enumerator;
    VALUE pred;

    pred = rb_block_proc();

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_enum&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_pred&quot;), pred);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_inverted&quot;), Qtrue);

    rb_block_call(enumerator, idInitialize, 0, 0, slicewhen_i, enumerator);
    return enumerator;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-collect">
            
              <b>enum.collect { |obj| block } &rarr; array
enum.collect                 &rarr; an_enumerator</b>
            
            <a href="../classes/Enumerable.html#method-i-collect" name="method-i-collect" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>(1..4).map { |i| i*i }      #=&gt; [1, 4, 9, 16]
(1..4).collect { &quot;cat&quot;  }   #=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-collect_source')" id="l_method-i-collect_source">show</a>
                
              </p>
              <div id="method-i-collect_source" class="dyn-source">
                <pre>static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, collect_i, ary);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-collect_concat">
            
              <b>enum.collect_concat { |obj| block } &rarr; array
enum.collect_concat                 &rarr; an_enumerator</b>
            
            <a href="../classes/Enumerable.html#method-i-collect_concat" name="method-i-collect_concat" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>[1, 2, 3, 4].flat_map { |e| [e, -e] } #=&gt; [1, -1, 2, -2, 3, -3, 4, -4]
[[1, 2], [3, 4]].flat_map { |e| e + [100] } #=&gt; [1, 2, 100, 3, 4, 100]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-collect_concat_source')" id="l_method-i-collect_concat_source">show</a>
                
              </p>
              <div id="method-i-collect_concat_source" class="dyn-source">
                <pre>static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-count">
            
              <b>enum.count                 &rarr; int
enum.count(item)           &rarr; int
enum.count { |obj| block } &rarr; int
</b>
            
            <a href="../classes/Enumerable.html#method-i-count" name="method-i-count" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns the number of items in <code>enum</code> through enumeration. If an
argument is given, the number of items in <code>enum</code> that are equal
to <code>item</code> are counted.  If a block is given, it counts the
number of elements yielding a true value.</p>

<pre><code>ary = [1, 2, 4, 2]
ary.count               #=&gt; 4
ary.count(2)            #=&gt; 2
ary.count{ |x| x%2==0 } #=&gt; 3
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-count_source')" id="l_method-i-count_source">show</a>
                
              </p>
              <div id="method-i-count_source" class="dyn-source">
                <pre>static VALUE
enum_count(int argc, VALUE *argv, VALUE obj)
{
    VALUE item = Qnil;
    struct MEMO *memo;
    rb_block_call_func *func;

    if (argc == 0) {
        if (rb_block_given_p()) {
            func = count_iter_i;
        }
        else {
            func = count_all_i;
        }
    }
    else {
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;item);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        func = count_i;
    }

    memo = MEMO_NEW(item, 0, 0);
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return INT2NUM(memo-&gt;u3.cnt);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-cycle">
            
              <b>enum.cycle(n=nil) { |obj| block }  &rarr;  nil
enum.cycle(n=nil)                  &rarr;  an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-cycle" name="method-i-cycle" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Calls <em>block</em> for each element of <em>enum</em> repeatedly
<em>n</em> times or forever if none or <code>nil</code> is given.  If a
non-positive number is given or the collection is empty, does nothing. 
Returns <code>nil</code> if the loop has finished without getting
interrupted.</p>

<p><a href="Enumerable.html#method-i-cycle">#cycle</a> saves elements in an
internal array so changes to <em>enum</em> after the first pass have no
effect.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
a.cycle { |x| puts x }  # print, a, b, c, a, b, c,.. forever.
a.cycle(2) { |x| puts x }  # print, a, b, c, a, b, c.
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-cycle_source')" id="l_method-i-cycle_source">show</a>
                
              </p>
              <div id="method-i-cycle_source" class="dyn-source">
                <pre>static VALUE
enum_cycle(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    VALUE nv = Qnil;
    long n, i, len;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_cycle_size);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }
    ary = rb_ary_new();
    RBASIC_CLEAR_CLASS(ary);
    rb_block_call(obj, id_each, 0, 0, cycle_i, ary);
    len = RARRAY_LEN(ary);
    if (len == 0) return Qnil;
    while (n &lt; 0 || 0 &lt; --n) {
        for (i=0; i&lt;len; i++) {
            rb_yield(RARRAY_AREF(ary, i));
        }
    }
    return Qnil;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-detect">
            
              <b>enum.detect(ifnone = nil) { |obj| block } &rarr; obj or nil
enum.detect(ifnone = nil)                 &rarr; an_enumerator</b>
            
            <a href="../classes/Enumerable.html#method-i-detect" name="method-i-detect" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for
which <em>block</em> is not false.  If no object matches, calls
<em>ifnone</em> and returns its result when it is specified, or returns
<code>nil</code> otherwise.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>(1..10).detect   { |i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
(1..100).find    { |i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 35
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-detect_source')" id="l_method-i-detect_source">show</a>
                
              </p>
              <div id="method-i-detect_source" class="dyn-source">
                <pre>static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE if_none;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    memo = MEMO_NEW(Qundef, 0, 0);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)memo);
    if (memo-&gt;u3.cnt) {
        return memo-&gt;v1;
    }
    if (!NIL_P(if_none)) {
        return rb_funcallv(if_none, id_call, 0, 0);
    }
    return Qnil;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-drop">
            
              <b>enum.drop(n)               &rarr; array
</b>
            
            <a href="../classes/Enumerable.html#method-i-drop" name="method-i-drop" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Drops first n elements from <em>enum</em>, and returns rest elements in an
array.</p>

<pre><code>a = [1, 2, 3, 4, 5, 0]
a.drop(3)             #=&gt; [4, 5, 0]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-drop_source')" id="l_method-i-drop_source">show</a>
                
              </p>
              <div id="method-i-drop_source" class="dyn-source">
                <pre>static VALUE
enum_drop(VALUE obj, VALUE n)
{
    VALUE result;
    struct MEMO *memo;
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    result = rb_ary_new();
    memo = MEMO_NEW(result, 0, len);
    rb_block_call(obj, id_each, 0, 0, drop_i, (VALUE)memo);
    return result;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-drop_while">
            
              <b>enum.drop_while { |arr| block }  &rarr; array
enum.drop_while                  &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-drop_while" name="method-i-drop_while" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Drops elements up to, but not including, the first element for which the
block returns <code>nil</code> or <code>false</code> and returns an array
containing the remaining elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>a = [1, 2, 3, 4, 5, 0]
a.drop_while { |i| i &lt; 3 }   #=&gt; [3, 4, 5, 0]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-drop_while_source')" id="l_method-i-drop_while_source">show</a>
                
              </p>
              <div id="method-i-drop_while_source" class="dyn-source">
                <pre>static VALUE
enum_drop_while(VALUE obj)
{
    VALUE result;
    struct MEMO *memo;

    RETURN_ENUMERATOR(obj, 0, 0);
    result = rb_ary_new();
    memo = MEMO_NEW(result, 0, FALSE);
    rb_block_call(obj, id_each, 0, 0, drop_while_i, (VALUE)memo);
    return result;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-each_cons">
            
              <b>enum.each_cons(n) { ... } &rarr;  nil
enum.each_cons(n)         &rarr;  an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-each_cons" name="method-i-each_cons" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Iterates the given block for each array of consecutive &lt;n&gt; elements. 
If no block is given, returns an enumerator.</p>

<p>e.g.:</p>

<pre><code>(1..10).each_cons(3) { |a| p a }
# outputs below
[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 10]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-each_cons_source')" id="l_method-i-each_cons_source">show</a>
                
              </p>
              <div id="method-i-each_cons_source" class="dyn-source">
                <pre>static VALUE
enum_each_cons(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    struct MEMO *memo;
    int arity;

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid size&quot;);
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;n, enum_each_cons_size);
    arity = rb_block_arity();
    if (enum_size_over_p(obj, size)) return Qnil;
    memo = MEMO_NEW(rb_ary_new2(size), dont_recycle_block_arg(arity), size);
    rb_block_call(obj, id_each, 0, 0, each_cons_i, (VALUE)memo);

    return Qnil;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-each_entry">
            
              <b>enum.each_entry { |obj| block }  &rarr; enum
enum.each_entry                  &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-each_entry" name="method-i-each_entry" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Calls <em>block</em> once for each element in <code>self</code>, passing
that element as a parameter, converting multiple values from yield to an
array.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>class Foo
  include Enumerable
  def each
    yield 1
    yield 1, 2
    yield
  end
end
Foo.new.each_entry{ |o| p o }
</code></pre>

<p>produces:</p>

<pre><code>1
[1, 2]
nil
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-each_entry_source')" id="l_method-i-each_entry_source">show</a>
                
              </p>
              <div id="method-i-each_entry_source" class="dyn-source">
                <pre>static VALUE
enum_each_entry(int argc, VALUE *argv, VALUE obj)
{
    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);
    rb_block_call(obj, id_each, argc, argv, each_val_i, 0);
    return obj;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-each_slice">
            
              <b>enum.each_slice(n) { ... }  &rarr;  nil
enum.each_slice(n)          &rarr;  an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-each_slice" name="method-i-each_slice" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Iterates the given block for each slice of &lt;n&gt; elements.  If no block
is given, returns an enumerator.</p>

<pre><code>(1..10).each_slice(3) { |a| p a }
# outputs below
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[10]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-each_slice_source')" id="l_method-i-each_slice_source">show</a>
                
              </p>
              <div id="method-i-each_slice_source" class="dyn-source">
                <pre>static VALUE
enum_each_slice(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE ary;
    struct MEMO *memo;
    int arity;

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid slice size&quot;);
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;n, enum_each_slice_size);
    size = limit_by_enum_size(obj, size);
    ary = rb_ary_new2(size);
    arity = rb_block_arity();
    memo = MEMO_NEW(ary, dont_recycle_block_arg(arity), size);
    rb_block_call(obj, id_each, 0, 0, each_slice_i, (VALUE)memo);
    ary = memo-&gt;v1;
    if (RARRAY_LEN(ary) &gt; 0) rb_yield(ary);

    return Qnil;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-each_with_index">
            
              <b>enum.each_with_index(*args) { |obj, i| block } &rarr;  enum
enum.each_with_index(*args)                    &rarr;  an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-each_with_index" name="method-i-each_with_index" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Calls <em>block</em> with two arguments, the item and its index, for each
item in <em>enum</em>.  Given arguments are passed through to each().</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>hash = Hash.new
%w(cat dog wombat).each_with_index { |item, index|
  hash[item] = index
}
hash   #=&gt; {&quot;cat&quot;=&gt;0, &quot;dog&quot;=&gt;1, &quot;wombat&quot;=&gt;2}
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-each_with_index_source')" id="l_method-i-each_with_index_source">show</a>
                
              </p>
              <div id="method-i-each_with_index_source" class="dyn-source">
                <pre>static VALUE
enum_each_with_index(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    memo = MEMO_NEW(0, 0, 0);
    rb_block_call(obj, id_each, argc, argv, each_with_index_i, (VALUE)memo);
    return obj;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-each_with_object">
            
              <b>enum.each_with_object(obj) { |(*args), memo_obj| ... }  &rarr;  obj
enum.each_with_object(obj)                              &rarr;  an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-each_with_object" name="method-i-each_with_object" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Iterates the given block for each element with an arbitrary object given,
and returns the initially given object.</p>

<p>If no block is given, returns an enumerator.</p>

<pre><code>evens = (1..10).each_with_object([]) { |i, a| a &lt;&lt; i*2 }
#=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-each_with_object_source')" id="l_method-i-each_with_object_source">show</a>
                
              </p>
              <div id="method-i-each_with_object_source" class="dyn-source">
                <pre>static VALUE
enum_each_with_object(VALUE obj, VALUE memo)
{
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;memo, enum_size);

    rb_block_call(obj, id_each, 0, 0, each_with_object_i, memo);

    return memo;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-entries">
            
              <b>enum.entries(*args)   &rarr; array</b>
            
            <a href="../classes/Enumerable.html#method-i-entries" name="method-i-entries" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns an array containing the items in <em>enum</em>.</p>

<pre><code>(1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
{ &#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2, &#39;c&#39;=&gt;3 }.to_a   #=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]

require &#39;prime&#39;
Prime.entries 10                  #=&gt; [2, 3, 5, 7]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-entries_source')" id="l_method-i-entries_source">show</a>
                
              </p>
              <div id="method-i-entries_source" class="dyn-source">
                <pre>static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);
    OBJ_INFECT(ary, obj);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-find">
            
              <b>enum.find(ifnone = nil)   { |obj| block } &rarr; obj or nil
enum.find(ifnone = nil)                   &rarr; an_enumerator</b>
            
            <a href="../classes/Enumerable.html#method-i-find" name="method-i-find" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for
which <em>block</em> is not false.  If no object matches, calls
<em>ifnone</em> and returns its result when it is specified, or returns
<code>nil</code> otherwise.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>(1..10).detect   { |i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
(1..100).find    { |i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 35
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-find_source')" id="l_method-i-find_source">show</a>
                
              </p>
              <div id="method-i-find_source" class="dyn-source">
                <pre>static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE if_none;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    memo = MEMO_NEW(Qundef, 0, 0);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)memo);
    if (memo-&gt;u3.cnt) {
        return memo-&gt;v1;
    }
    if (!NIL_P(if_none)) {
        return rb_funcallv(if_none, id_call, 0, 0);
    }
    return Qnil;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-find_all">
            
              <b>enum.find_all { |obj| block } &rarr; array
enum.find_all                 &rarr; an_enumerator</b>
            
            <a href="../classes/Enumerable.html#method-i-find_all" name="method-i-find_all" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns an array containing all elements of <code>enum</code> for which the
given <code>block</code> returns a true value.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre><code>(1..10).find_all { |i|  i % 3 == 0 }   #=&gt; [3, 6, 9]

[1,2,3,4,5].select { |num|  num.even?  }   #=&gt; [2, 4]
</code></pre>

<p>See also <a href="Enumerable.html#method-i-reject">#reject</a>.</p>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-find_all_source')" id="l_method-i-find_all_source">show</a>
                
              </p>
              <div id="method-i-find_all_source" class="dyn-source">
                <pre>static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-find_index">
            
              <b>enum.find_index(value)          &rarr; int or nil
enum.find_index { |obj| block } &rarr; int or nil
enum.find_index                 &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-find_index" name="method-i-find_index" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Compares each entry in <em>enum</em> with <em>value</em> or passes to
<em>block</em>.  Returns the index for the first for which the evaluated
value is non-false.  If no object matches, returns <code>nil</code></p>

<p>If neither block nor argument is given, an enumerator is returned instead.</p>

<pre><code>(1..10).find_index  { |i| i % 5 == 0 and i % 7 == 0 }  #=&gt; nil
(1..100).find_index { |i| i % 5 == 0 and i % 7 == 0 }  #=&gt; 34
(1..100).find_index(50)                                #=&gt; 49
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-find_index_source')" id="l_method-i-find_index_source">show</a>
                
              </p>
              <div id="method-i-find_index_source" class="dyn-source">
                <pre>static VALUE
enum_find_index(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;  /* [return value, current index, ] */
    VALUE condition_value = Qnil;
    rb_block_call_func *func;

    if (argc == 0) {
        RETURN_ENUMERATOR(obj, 0, 0);
        func = find_index_iter_i;
    }
    else {
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;condition_value);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        func = find_index_i;
    }

    memo = MEMO_NEW(Qnil, condition_value, 0);
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return memo-&gt;v1;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-first">
            
              <b>enum.first       &rarr;  obj or nil
enum.first(n)    &rarr;  an_array
</b>
            
            <a href="../classes/Enumerable.html#method-i-first" name="method-i-first" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns the first element, or the first <code>n</code> elements, of the
enumerable. If the enumerable is empty, the first form returns
<code>nil</code>, and the second form returns an empty array.</p>

<pre><code>%w[foo bar baz].first     #=&gt; &quot;foo&quot;
%w[foo bar baz].first(2)  #=&gt; [&quot;foo&quot;, &quot;bar&quot;]
%w[foo bar baz].first(10) #=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]
[].first                  #=&gt; nil
[].first(10)              #=&gt; []
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-first_source')" id="l_method-i-first_source">show</a>
                
              </p>
              <div id="method-i-first_source" class="dyn-source">
                <pre>static VALUE
enum_first(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        return enum_take(obj, argv[0]);
    }
    else {
        memo = MEMO_NEW(Qnil, 0, 0);
        rb_block_call(obj, id_each, 0, 0, first_i, (VALUE)memo);
        return memo-&gt;v1;
    }
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-flat_map">
            
              <b>enum.flat_map       { |obj| block } &rarr; array
enum.flat_map                       &rarr; an_enumerator</b>
            
            <a href="../classes/Enumerable.html#method-i-flat_map" name="method-i-flat_map" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>[1, 2, 3, 4].flat_map { |e| [e, -e] } #=&gt; [1, -1, 2, -2, 3, -3, 4, -4]
[[1, 2], [3, 4]].flat_map { |e| e + [100] } #=&gt; [1, 2, 100, 3, 4, 100]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-flat_map_source')" id="l_method-i-flat_map_source">show</a>
                
              </p>
              <div id="method-i-flat_map_source" class="dyn-source">
                <pre>static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-grep">
            
              <b>enum.grep(pattern)                  &rarr; array
enum.grep(pattern) { |obj| block }  &rarr; array
</b>
            
            <a href="../classes/Enumerable.html#method-i-grep" name="method-i-grep" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns an array of every element in <em>enum</em> for which <code>Pattern
=== element</code>. If the optional <em>block</em> is supplied, each
matching element is passed to it, and the block&#39;s result is stored in
the output array.</p>

<pre><code>(1..100).grep 38..44   #=&gt; [38, 39, 40, 41, 42, 43, 44]
c = IO.constants
c.grep(/SEEK/)         #=&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]
res = c.grep(/SEEK/) { |v| IO.const_get(v) }
res                    #=&gt; [0, 1, 2]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-grep_source')" id="l_method-i-grep_source">show</a>
                
              </p>
              <div id="method-i-grep_source" class="dyn-source">
                <pre>static VALUE
enum_grep(VALUE obj, VALUE pat)
{
    VALUE ary = rb_ary_new();
    struct MEMO *memo = MEMO_NEW(pat, ary, Qtrue);

    rb_block_call(obj, id_each, 0, 0, rb_block_given_p() ? grep_iter_i : grep_i, (VALUE)memo);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-grep_v">
            
              <b>enum.grep_v(pattern)                  &rarr; array
enum.grep_v(pattern) { |obj| block }  &rarr; array
</b>
            
            <a href="../classes/Enumerable.html#method-i-grep_v" name="method-i-grep_v" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Inverted version of <a href="Enumerable.html#method-i-grep">#grep</a>.
Returns an array of every element in <em>enum</em> for which not
<code>Pattern === element</code>.</p>

<pre><code>(1..10).grep_v 2..5   #=&gt; [1, 6, 7, 8, 9, 10]
res =(1..10).grep_v(2..5) { |v| v * 2 }
res                    #=&gt; [2, 12, 14, 16, 18, 20]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-grep_v_source')" id="l_method-i-grep_v_source">show</a>
                
              </p>
              <div id="method-i-grep_v_source" class="dyn-source">
                <pre>static VALUE
enum_grep_v(VALUE obj, VALUE pat)
{
    VALUE ary = rb_ary_new();
    struct MEMO *memo = MEMO_NEW(pat, ary, Qfalse);

    rb_block_call(obj, id_each, 0, 0, rb_block_given_p() ? grep_iter_i : grep_i, (VALUE)memo);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-group_by">
            
              <b>enum.group_by { |obj| block } &rarr; a_hash
enum.group_by                 &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-group_by" name="method-i-group_by" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Groups the collection by result of the block.  Returns a hash where the
keys are the evaluated result from the block and the values are arrays of
elements in the collection that correspond to the key.</p>

<p>If no block is given an enumerator is returned.</p>

<pre><code>(1..6).group_by { |i| i%3 }   #=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-group_by_source')" id="l_method-i-group_by_source">show</a>
                
              </p>
              <div id="method-i-group_by_source" class="dyn-source">
                <pre>static VALUE
enum_group_by(VALUE obj)
{
    VALUE hash;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    hash = rb_hash_new();
    rb_block_call(obj, id_each, 0, 0, group_by_i, hash);
    OBJ_INFECT(hash, obj);

    return hash;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-include-3F">
            
              <b>enum.include?(obj)     &rarr; true or false</b>
            
            <a href="../classes/Enumerable.html#method-i-include-3F" name="method-i-include-3F" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns <code>true</code> if any member of <em>enum</em> equals
<em>obj</em>. Equality is tested using <code>==</code>.</p>

<pre><code>IO.constants.include? :SEEK_SET          #=&gt; true
IO.constants.include? :SEEK_NO_FURTHER   #=&gt; false
IO.constants.member? :SEEK_SET          #=&gt; true
IO.constants.member? :SEEK_NO_FURTHER   #=&gt; false
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-include-3F_source')" id="l_method-i-include-3F_source">show</a>
                
              </p>
              <div id="method-i-include-3F_source" class="dyn-source">
                <pre>static VALUE
enum_member(VALUE obj, VALUE val)
{
    struct MEMO *memo = MEMO_NEW(val, Qfalse, 0);

    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-inject">
            
              <b>enum.inject(initial, sym) &rarr; obj
enum.inject(sym)          &rarr; obj
enum.inject(initial) { |memo, obj| block }  &rarr; obj
enum.inject          { |memo, obj| block }  &rarr; obj</b>
            
            <a href="../classes/Enumerable.html#method-i-inject" name="method-i-inject" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Combines all elements of <em>enum</em> by applying a binary operation,
specified by a block or a symbol that names a method or operator.</p>

<p>If you specify a block, then for each element in <em>enum</em> the block is
passed an accumulator value (<em>memo</em>) and the element. If you specify
a symbol instead, then each element in the collection will be passed to the
named method of <em>memo</em>. In either case, the result becomes the new
value for <em>memo</em>. At the end of the iteration, the final value of
<em>memo</em> is the return value for the method.</p>

<p>If you do not explicitly specify an <em>initial</em> value for
<em>memo</em>, then the first element of collection is used as the initial
value of <em>memo</em>.</p>

<pre><code># Sum some numbers
(5..10).reduce(:+)                             #=&gt; 45
# Same using a block and inject
(5..10).inject { |sum, n| sum + n }            #=&gt; 45
# Multiply some numbers
(5..10).reduce(1, :*)                          #=&gt; 151200
# Same using a block
(5..10).inject(1) { |product, n| product * n } #=&gt; 151200
# find the longest word
longest = %w{ cat sheep bear }.inject do |memo, word|
   memo.length &gt; word.length ? memo : word
end
longest                                        #=&gt; &quot;sheep&quot;
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-inject_source')" id="l_method-i-inject_source">show</a>
                
              </p>
              <div id="method-i-inject_source" class="dyn-source">
                <pre>static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE init, op;
    rb_block_call_func *iter = inject_i;
    ID id;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;init, &amp;op)) {
      case 0:
        init = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        id = rb_check_id(&amp;init);
        op = id ? ID2SYM(id) : init;
        init = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        id = rb_check_id(&amp;op);
        if (id) op = ID2SYM(id);
        iter = inject_op_i;
        break;
    }
    memo = MEMO_NEW(init, Qnil, op);
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo-&gt;v1 == Qundef) return Qnil;
    return memo-&gt;v1;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-lazy">
            
              <b>e.lazy &rarr; lazy_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-lazy" name="method-i-lazy" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns a lazy enumerator, whose methods map/collect,
flat_map/collect_concat, select/find_all, reject, grep, <a
href="Enumerable.html#method-i-grep_v">#grep_v</a>, zip, take, <a
href="Enumerable.html#method-i-take_while">#take_while</a>, drop, and <a
href="Enumerable.html#method-i-drop_while">#drop_while</a> enumerate values
only on an as-needed basis.  However, if a block is given to zip, values
are enumerated immediately.</p>

<h3 id="method-i-lazy-label-Example">Example</h3>

<p>The following program finds pythagorean triples:</p>

<pre><code>def pythagorean_triples
  (1..Float::INFINITY).lazy.flat_map {|z|
    (1..z).flat_map {|x|
      (x..z).select {|y|
        x**2 + y**2 == z**2
      }.map {|y|
        [x, y, z]
      }
    }
  }
end
# show first ten pythagorean triples
p pythagorean_triples.take(10).force # take is lazy, so force is needed
p pythagorean_triples.first(10)      # first is eager
# show pythagorean triples less than 100
p pythagorean_triples.take_while { |*, z| z &lt; 100 }.force
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-lazy_source')" id="l_method-i-lazy_source">show</a>
                
              </p>
              <div id="method-i-lazy_source" class="dyn-source">
                <pre>static VALUE
enumerable_lazy(VALUE obj)
{
    VALUE result = lazy_to_enum_i(obj, sym_each, 0, 0, lazyenum_size);
    /* Qfalse indicates that the Enumerator::Lazy has no method name */
    rb_ivar_set(result, id_method, Qfalse);
    return result;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-map">
            
              <b>enum.map     { |obj| block } &rarr; array
enum.map                     &rarr; an_enumerator</b>
            
            <a href="../classes/Enumerable.html#method-i-map" name="method-i-map" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>(1..4).map { |i| i*i }      #=&gt; [1, 4, 9, 16]
(1..4).collect { &quot;cat&quot;  }   #=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-map_source')" id="l_method-i-map_source">show</a>
                
              </p>
              <div id="method-i-map_source" class="dyn-source">
                <pre>static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, collect_i, ary);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-max">
            
              <b>enum.max                   &rarr; obj
enum.max { |a, b| block }  &rarr; obj
enum.max(n)                &rarr; obj
enum.max(n) {|a,b| block } &rarr; obj
</b>
            
            <a href="../classes/Enumerable.html#method-i-max" name="method-i-max" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns the object in <em>enum</em> with the maximum value. The first form
assumes all objects implement <code>Comparable</code>; the second uses the
block to return <em>a &lt;=&gt; b</em>.</p>

<pre><code>a = %w(albatross dog horse)
a.max                                   #=&gt; &quot;horse&quot;
a.max { |a, b| a.length &lt;=&gt; b.length }  #=&gt; &quot;albatross&quot;
</code></pre>

<p>If the <code>n</code> argument is given, maximum <code>n</code> elements
are returned as an array.</p>

<pre><code>a = %w[albatross dog horse]
a.max(2)                                  #=&gt; [&quot;horse&quot;, &quot;dog&quot;]
a.max(2) {|a, b| a.length &lt;=&gt; b.length }  #=&gt; [&quot;albatross&quot;, &quot;horse&quot;]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-max_source')" id="l_method-i-max_source">show</a>
                
              </p>
              <div id="method-i-max_source" class="dyn-source">
                <pre>static VALUE
enum_max(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_NEW(Qundef, 0, 0);
    VALUE result;
    VALUE num;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;num);

    if (!NIL_P(num))
       return nmin_run(obj, num, 0, 1);

    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, max_i, (VALUE)memo);
    }
    result = memo-&gt;v1;
    if (result == Qundef) return Qnil;
    return result;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-max_by">
            
              <b>enum.max_by {|obj| block }      &rarr; obj
enum.max_by                     &rarr; an_enumerator
enum.max_by(n) {|obj| block }   &rarr; obj
enum.max_by(n)                  &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-max_by" name="method-i-max_by" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns the object in <em>enum</em> that gives the maximum value from the
given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>a = %w(albatross dog horse)
a.max_by { |x| x.length }   #=&gt; &quot;albatross&quot;
</code></pre>

<p>If the <code>n</code> argument is given, minimum <code>n</code> elements
are returned as an array.</p>

<pre><code>a = %w[albatross dog horse]
a.max_by(2) {|x| x.length } #=&gt; [&quot;albatross&quot;, &quot;horse&quot;]
</code></pre>

<p>enum.max_by(n) can be used to implement weighted random sampling. Following
example implements and use Enumerable#wsample.</p>

<pre><code>module Enumerable
  # weighted random sampling.
  #
  # Pavlos S. Efraimidis, Paul G. Spirakis
  # Weighted random sampling with a reservoir
  # Information Processing Letters
  # Volume 97, Issue 5 (16 March 2006)
  def wsample(n)
    self.max_by(n) {|v| rand ** (1.0/yield(v)) }
  end
end
e = (-20..20).to_a*10000
a = e.wsample(20000) {|x|
  Math.exp(-(x/5.0)**2) # normal distribution
}
# a is 20000 samples from e.
p a.length #=&gt; 20000
h = a.group_by {|x| x }
-10.upto(10) {|x| puts &quot;*&quot; * (h[x].length/30.0).to_i if h[x] }
#=&gt; *
#   ***
#   ******
#   ***********
#   ******************
#   *****************************
#   *****************************************
#   ****************************************************
#   ***************************************************************
#   ********************************************************************
#   ***********************************************************************
#   ***********************************************************************
#   **************************************************************
#   ****************************************************
#   ***************************************
#   ***************************
#   ******************
#   ***********
#   *******
#   ***
#   *
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-max_by_source')" id="l_method-i-max_by_source">show</a>
                
              </p>
              <div id="method-i-max_by_source" class="dyn-source">
                <pre>static VALUE
enum_max_by(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE num;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;num);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    if (!NIL_P(num))
        return nmin_run(obj, num, 1, 1);

    memo = MEMO_NEW(Qundef, Qnil, 0);
    rb_block_call(obj, id_each, 0, 0, max_by_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-member-3F">
            
              <b>enum.member?(obj)      &rarr; true or false</b>
            
            <a href="../classes/Enumerable.html#method-i-member-3F" name="method-i-member-3F" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns <code>true</code> if any member of <em>enum</em> equals
<em>obj</em>. Equality is tested using <code>==</code>.</p>

<pre><code>IO.constants.include? :SEEK_SET          #=&gt; true
IO.constants.include? :SEEK_NO_FURTHER   #=&gt; false
IO.constants.member? :SEEK_SET          #=&gt; true
IO.constants.member? :SEEK_NO_FURTHER   #=&gt; false
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-member-3F_source')" id="l_method-i-member-3F_source">show</a>
                
              </p>
              <div id="method-i-member-3F_source" class="dyn-source">
                <pre>static VALUE
enum_member(VALUE obj, VALUE val)
{
    struct MEMO *memo = MEMO_NEW(val, Qfalse, 0);

    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-min">
            
              <b>enum.min                     &rarr; obj
enum.min {| a,b | block }    &rarr; obj
enum.min(n)                  &rarr; array
enum.min(n) {| a,b | block } &rarr; array
</b>
            
            <a href="../classes/Enumerable.html#method-i-min" name="method-i-min" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns the object in <em>enum</em> with the minimum value. The first form
assumes all objects implement <code>Comparable</code>; the second uses the
block to return <em>a &lt;=&gt; b</em>.</p>

<pre><code>a = %w(albatross dog horse)
a.min                                   #=&gt; &quot;albatross&quot;
a.min { |a, b| a.length &lt;=&gt; b.length }  #=&gt; &quot;dog&quot;
</code></pre>

<p>If the <code>n</code> argument is given, minimum <code>n</code> elements
are returned as an array.</p>

<pre><code>a = %w[albatross dog horse]
a.min(2)                                  #=&gt; [&quot;albatross&quot;, &quot;dog&quot;]
a.min(2) {|a, b| a.length &lt;=&gt; b.length }  #=&gt; [&quot;dog&quot;, &quot;horse&quot;]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-min_source')" id="l_method-i-min_source">show</a>
                
              </p>
              <div id="method-i-min_source" class="dyn-source">
                <pre>static VALUE
enum_min(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_NEW(Qundef, 0, 0);
    VALUE result;
    VALUE num;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;num);

    if (!NIL_P(num))
       return nmin_run(obj, num, 0, 0);

    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, min_ii, (VALUE)memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, min_i, (VALUE)memo);
    }
    result = memo-&gt;v1;
    if (result == Qundef) return Qnil;
    return result;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-min_by">
            
              <b>enum.min_by {|obj| block }      &rarr; obj
enum.min_by                     &rarr; an_enumerator
enum.min_by(n) {|obj| block }   &rarr; array
enum.min_by(n)                  &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-min_by" name="method-i-min_by" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns the object in <em>enum</em> that gives the minimum value from the
given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>a = %w(albatross dog horse)
a.min_by { |x| x.length }   #=&gt; &quot;dog&quot;
</code></pre>

<p>If the <code>n</code> argument is given, minimum <code>n</code> elements
are returned as an array.</p>

<pre><code>a = %w[albatross dog horse]
p a.min_by(2) {|x| x.length } #=&gt; [&quot;dog&quot;, &quot;horse&quot;]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-min_by_source')" id="l_method-i-min_by_source">show</a>
                
              </p>
              <div id="method-i-min_by_source" class="dyn-source">
                <pre>static VALUE
enum_min_by(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE num;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;num);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    if (!NIL_P(num))
        return nmin_run(obj, num, 1, 0);

    memo = MEMO_NEW(Qundef, Qnil, 0);
    rb_block_call(obj, id_each, 0, 0, min_by_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-minmax">
            
              <b>enum.minmax                  &rarr; [min, max]
enum.minmax { |a, b| block } &rarr; [min, max]
</b>
            
            <a href="../classes/Enumerable.html#method-i-minmax" name="method-i-minmax" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns a two element array which contains the minimum and the maximum
value in the enumerable.  The first form assumes all objects implement
<code>Comparable</code>; the second uses the block to return <em>a
&lt;=&gt; b</em>.</p>

<pre><code>a = %w(albatross dog horse)
a.minmax                                  #=&gt; [&quot;albatross&quot;, &quot;horse&quot;]
a.minmax { |a, b| a.length &lt;=&gt; b.length } #=&gt; [&quot;dog&quot;, &quot;albatross&quot;]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-minmax_source')" id="l_method-i-minmax_source">show</a>
                
              </p>
              <div id="method-i-minmax_source" class="dyn-source">
                <pre>static VALUE
enum_minmax(VALUE obj)
{
    struct MEMO *memo = MEMO_NEW(Qundef, Qundef, Qundef);
    struct minmax_t *m = (struct minmax_t *)&amp;memo-&gt;v1;

    m-&gt;min = Qundef;
    m-&gt;last = Qundef;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, minmax_ii, (VALUE)memo);
        if (m-&gt;last != Qundef)
            minmax_ii_update(m-&gt;last, m-&gt;last, m);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, minmax_i, (VALUE)memo);
        if (m-&gt;last != Qundef)
            minmax_i_update(m-&gt;last, m-&gt;last, m);
    }
    if (m-&gt;min != Qundef) {
        return rb_assoc_new(m-&gt;min, m-&gt;max);
    }
    return rb_assoc_new(Qnil, Qnil);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-minmax_by">
            
              <b>enum.minmax_by { |obj| block } &rarr; [min, max]
enum.minmax_by                 &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-minmax_by" name="method-i-minmax_by" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns a two element array containing the objects in <em>enum</em> that
correspond to the minimum and maximum values respectively from the given
block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>a = %w(albatross dog horse)
a.minmax_by { |x| x.length }   #=&gt; [&quot;dog&quot;, &quot;albatross&quot;]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-minmax_by_source')" id="l_method-i-minmax_by_source">show</a>
                
              </p>
              <div id="method-i-minmax_by_source" class="dyn-source">
                <pre>static VALUE
enum_minmax_by(VALUE obj)
{
    VALUE memo;
    struct minmax_by_t *m = NEW_MEMO_FOR(struct minmax_by_t, memo);

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    m-&gt;min_bv = Qundef;
    m-&gt;max_bv = Qundef;
    m-&gt;min = Qnil;
    m-&gt;max = Qnil;
    m-&gt;last_bv = Qundef;
    m-&gt;last = Qundef;
    rb_block_call(obj, id_each, 0, 0, minmax_by_i, memo);
    if (m-&gt;last_bv != Qundef)
        minmax_by_i_update(m-&gt;last_bv, m-&gt;last_bv, m-&gt;last, m-&gt;last, m);
    m = MEMO_FOR(struct minmax_by_t, memo);
    return rb_assoc_new(m-&gt;min, m-&gt;max);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-none-3F">
            
              <b>enum.none? [{ |obj| block }]   &rarr; true or false
</b>
            
            <a href="../classes/Enumerable.html#method-i-none-3F" name="method-i-none-3F" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block never returns <code>true</code> for
all elements. If the block is not given, <code>none?</code> will return
<code>true</code> only if none of the collection members is true.</p>

<pre><code>%w{ant bear cat}.none? { |word| word.length == 5 } #=&gt; true
%w{ant bear cat}.none? { |word| word.length &gt;= 4 } #=&gt; false
[].none?                                           #=&gt; true
[nil].none?                                        #=&gt; true
[nil, false].none?                                 #=&gt; true
[nil, false, true].none?                           #=&gt; false
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-none-3F_source')" id="l_method-i-none-3F_source">show</a>
                
              </p>
              <div id="method-i-none-3F_source" class="dyn-source">
                <pre>static VALUE
enum_none(VALUE obj)
{
    struct MEMO *memo = MEMO_NEW(Qtrue, 0, 0);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(none), (VALUE)memo);
    return memo-&gt;v1;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-one-3F">
            
              <b>enum.one? [{ |obj| block }]   &rarr; true or false
</b>
            
            <a href="../classes/Enumerable.html#method-i-one-3F" name="method-i-one-3F" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block returns <code>true</code> exactly
once. If the block is not given, <code>one?</code> will return
<code>true</code> only if exactly one of the collection members is true.</p>

<pre><code>%w{ant bear cat}.one? { |word| word.length == 4 }  #=&gt; true
%w{ant bear cat}.one? { |word| word.length &gt; 4 }   #=&gt; false
%w{ant bear cat}.one? { |word| word.length &lt; 4 }   #=&gt; false
[ nil, true, 99 ].one?                             #=&gt; false
[ nil, true, false ].one?                          #=&gt; true
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-one-3F_source')" id="l_method-i-one-3F_source">show</a>
                
              </p>
              <div id="method-i-one-3F_source" class="dyn-source">
                <pre>static VALUE
enum_one(VALUE obj)
{
    struct MEMO *memo = MEMO_NEW(Qundef, 0, 0);
    VALUE result;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(one), (VALUE)memo);
    result = memo-&gt;v1;
    if (result == Qundef) return Qfalse;
    return result;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-partition">
            
              <b>enum.partition { |obj| block } &rarr; [ true_array, false_array ]
enum.partition                 &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-partition" name="method-i-partition" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns two arrays, the first containing the elements of <em>enum</em> for
which the block evaluates to true, the second containing the rest.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>(1..6).partition { |v| v.even? }  #=&gt; [[2, 4, 6], [1, 3, 5]]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-partition_source')" id="l_method-i-partition_source">show</a>
                
              </p>
              <div id="method-i-partition_source" class="dyn-source">
                <pre>static VALUE
enum_partition(VALUE obj)
{
    struct MEMO *memo;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    memo = MEMO_NEW(rb_ary_new(), rb_ary_new(), 0);
    rb_block_call(obj, id_each, 0, 0, partition_i, (VALUE)memo);

    return rb_assoc_new(memo-&gt;v1, memo-&gt;v2);
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-reduce">
            
              <b>enum.reduce(initial, sym) &rarr; obj
enum.reduce(sym)          &rarr; obj
enum.reduce(initial) { |memo, obj| block }  &rarr; obj
enum.reduce          { |memo, obj| block }  &rarr; obj</b>
            
            <a href="../classes/Enumerable.html#method-i-reduce" name="method-i-reduce" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Combines all elements of <em>enum</em> by applying a binary operation,
specified by a block or a symbol that names a method or operator.</p>

<p>If you specify a block, then for each element in <em>enum</em> the block is
passed an accumulator value (<em>memo</em>) and the element. If you specify
a symbol instead, then each element in the collection will be passed to the
named method of <em>memo</em>. In either case, the result becomes the new
value for <em>memo</em>. At the end of the iteration, the final value of
<em>memo</em> is the return value for the method.</p>

<p>If you do not explicitly specify an <em>initial</em> value for
<em>memo</em>, then the first element of collection is used as the initial
value of <em>memo</em>.</p>

<pre><code># Sum some numbers
(5..10).reduce(:+)                             #=&gt; 45
# Same using a block and inject
(5..10).inject { |sum, n| sum + n }            #=&gt; 45
# Multiply some numbers
(5..10).reduce(1, :*)                          #=&gt; 151200
# Same using a block
(5..10).inject(1) { |product, n| product * n } #=&gt; 151200
# find the longest word
longest = %w{ cat sheep bear }.inject do |memo, word|
   memo.length &gt; word.length ? memo : word
end
longest                                        #=&gt; &quot;sheep&quot;
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-reduce_source')" id="l_method-i-reduce_source">show</a>
                
              </p>
              <div id="method-i-reduce_source" class="dyn-source">
                <pre>static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE init, op;
    rb_block_call_func *iter = inject_i;
    ID id;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;init, &amp;op)) {
      case 0:
        init = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        id = rb_check_id(&amp;init);
        op = id ? ID2SYM(id) : init;
        init = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        id = rb_check_id(&amp;op);
        if (id) op = ID2SYM(id);
        iter = inject_op_i;
        break;
    }
    memo = MEMO_NEW(init, Qnil, op);
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo-&gt;v1 == Qundef) return Qnil;
    return memo-&gt;v1;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-reject">
            
              <b>enum.reject { |obj| block } &rarr; array
enum.reject                 &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-reject" name="method-i-reject" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns an array for all elements of <code>enum</code> for which the given
<code>block</code> returns false.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre><code>(1..10).reject { |i|  i % 3 == 0 }   #=&gt; [1, 2, 4, 5, 7, 8, 10]

[1, 2, 3, 4, 5].reject { |num| num.even? } #=&gt; [1, 3, 5]
</code></pre>

<p>See also <a href="Enumerable.html#method-i-find_all">#find_all</a>.</p>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-reject_source')" id="l_method-i-reject_source">show</a>
                
              </p>
              <div id="method-i-reject_source" class="dyn-source">
                <pre>static VALUE
enum_reject(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, reject_i, ary);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-reverse_each">
            
              <b>enum.reverse_each(*args) { |item| block } &rarr;  enum
enum.reverse_each(*args)                  &rarr;  an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-reverse_each" name="method-i-reverse_each" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Builds a temporary array and traverses that array in reverse order.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>  (1..3).reverse_each { |v| p v }

produces:

  3
  2
  1</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-reverse_each_source')" id="l_method-i-reverse_each_source">show</a>
                
              </p>
              <div id="method-i-reverse_each_source" class="dyn-source">
                <pre>static VALUE
enum_reverse_each(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    long i;

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    ary = enum_to_a(argc, argv, obj);

    for (i = RARRAY_LEN(ary); --i &gt;= 0; ) {
        rb_yield(RARRAY_AREF(ary, i));
    }

    return obj;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-select">
            
              <b>enum.select   { |obj| block } &rarr; array
enum.select                   &rarr; an_enumerator</b>
            
            <a href="../classes/Enumerable.html#method-i-select" name="method-i-select" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns an array containing all elements of <code>enum</code> for which the
given <code>block</code> returns a true value.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre><code>(1..10).find_all { |i|  i % 3 == 0 }   #=&gt; [3, 6, 9]

[1,2,3,4,5].select { |num|  num.even?  }   #=&gt; [2, 4]
</code></pre>

<p>See also <a href="Enumerable.html#method-i-reject">#reject</a>.</p>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-select_source')" id="l_method-i-select_source">show</a>
                
              </p>
              <div id="method-i-select_source" class="dyn-source">
                <pre>static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-slice_after">
            
              <b>enum.slice_after(pattern)       &rarr; an_enumerator
enum.slice_after { |elt| bool } &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-slice_after" name="method-i-slice_after" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Creates an enumerator for each chunked elements. The ends of chunks are
defined by <em>pattern</em> and the block.</p>

<p>If <code><em>pattern</em> === <em>elt</em></code> returns <code>true</code>
or the block returns <code>true</code> for the element, the element is end
of a chunk.</p>

<p>The <code>===</code> and <em>block</em> is called from the first element to
the last element of <em>enum</em>.</p>

<p>The result enumerator yields the chunked elements as an array. So
<code>each</code> method can be called as follows:</p>

<pre><code>enum.slice_after(pattern).each { |ary| ... }
enum.slice_after { |elt| bool }.each { |ary| ... }</code></pre>

<p>Other methods of the <a href="Enumerator.html">Enumerator</a> class and <a
href="Enumerable.html">Enumerable</a> module, such as <code>map</code>,
etc., are also usable.</p>

<p>For example, continuation lines (lines end with backslash) can be
concatenated as follows:</p>

<pre><code>lines = [&quot;foo\n&quot;, &quot;bar\\\n&quot;, &quot;baz\n&quot;, &quot;\n&quot;, &quot;qux\n&quot;]
e = lines.slice_after(/(?&lt;!\\)\n\z/)
p e.to_a
#=&gt; [[&quot;foo\n&quot;], [&quot;bar\\\n&quot;, &quot;baz\n&quot;], [&quot;\n&quot;], [&quot;qux\n&quot;]]
p e.map {|ll| ll[0...-1].map {|l| l.sub(/\\\n\z/, &quot;&quot;) }.join + ll.last }
#=&gt;[&quot;foo\n&quot;, &quot;barbaz\n&quot;, &quot;\n&quot;, &quot;qux\n&quot;]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-slice_after_source')" id="l_method-i-slice_after_source">show</a>
                
              </p>
              <div id="method-i-slice_after_source" class="dyn-source">
                <pre>static VALUE
enum_slice_after(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;
    VALUE pat = Qnil, pred = Qnil;

    if (rb_block_given_p()) {
        if (0 &lt; argc)
            rb_raise(rb_eArgError, &quot;both pattern and block are given&quot;);
        pred = rb_block_proc();
    }
    else {
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;pat);
    }

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;sliceafter_enum&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;sliceafter_pat&quot;), pat);
    rb_ivar_set(enumerator, rb_intern(&quot;sliceafter_pred&quot;), pred);

    rb_block_call(enumerator, idInitialize, 0, 0, sliceafter_i, enumerator);
    return enumerator;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-slice_before">
            
              <b>enum.slice_before(pattern)                             &rarr; an_enumerator
enum.slice_before { |elt| bool }                       &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-slice_before" name="method-i-slice_before" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Creates an enumerator for each chunked elements. The beginnings of chunks
are defined by <em>pattern</em> and the block.</p>

<p>If <code><em>pattern</em> === <em>elt</em></code> returns <code>true</code>
or the block returns <code>true</code> for the element, the element is
beginning of a chunk.</p>

<p>The <code>===</code> and <em>block</em> is called from the first element to
the last element of <em>enum</em>.  The result for the first element is
ignored.</p>

<p>The result enumerator yields the chunked elements as an array. So
<code>each</code> method can be called as follows:</p>

<pre><code>enum.slice_before(pattern).each { |ary| ... }
enum.slice_before { |elt| bool }.each { |ary| ... }</code></pre>

<p>Other methods of the <a href="Enumerator.html">Enumerator</a> class and <a
href="Enumerable.html">Enumerable</a> module, such as map, etc., are also
usable.</p>

<p>For example, iteration over <a href="../files/ChangeLog.html">ChangeLog</a>
entries can be implemented as follows:</p>

<pre><code># iterate over ChangeLog entries.
open(&quot;ChangeLog&quot;) { |f|
  f.slice_before(/\A\S/).each { |e| pp e }
}

# same as above.  block is used instead of pattern argument.
open(&quot;ChangeLog&quot;) { |f|
  f.slice_before { |line| /\A\S/ === line }.each { |e| pp e }
}
</code></pre>

<p>“svn proplist -R” produces multiline output for each file. They can be
chunked as follows:</p>

<pre><code>IO.popen([{&quot;LC_ALL&quot;=&gt;&quot;C&quot;}, &quot;svn&quot;, &quot;proplist&quot;, &quot;-R&quot;]) { |f|
  f.lines.slice_before(/\AProp/).each { |lines| p lines }
}
#=&gt; [&quot;Properties on &#39;.&#39;:\n&quot;, &quot;  svn:ignore\n&quot;, &quot;  svk:merge\n&quot;]
#   [&quot;Properties on &#39;goruby.c&#39;:\n&quot;, &quot;  svn:eol-style\n&quot;]
#   [&quot;Properties on &#39;complex.c&#39;:\n&quot;, &quot;  svn:mime-type\n&quot;, &quot;  svn:eol-style\n&quot;]
#   [&quot;Properties on &#39;regparse.c&#39;:\n&quot;, &quot;  svn:eol-style\n&quot;]
#   ...
</code></pre>

<p>If the block needs to maintain state over multiple elements, local
variables can be used. For example, three or more consecutive increasing
numbers can be squashed as follows:</p>

<pre><code>a = [0, 2, 3, 4, 6, 7, 9]
prev = a[0]
p a.slice_before { |e|
  prev, prev2 = e, prev
  prev2 + 1 != e
}.map { |es|
  es.length &lt;= 2 ? es.join(&quot;,&quot;) : &quot;#{es.first}-#{es.last}&quot;
}.join(&quot;,&quot;)
#=&gt; &quot;0,2-4,6,7,9&quot;
</code></pre>

<p>However local variables should be used carefully if the result enumerator
is enumerated twice or more. The local variables should be initialized for
each enumeration. <a href="Enumerator.html#method-c-new">Enumerator.new</a>
can be used to do it.</p>

<pre><code># Word wrapping.  This assumes all characters have same width.
def wordwrap(words, maxwidth)
  Enumerator.new {|y|
    # cols is initialized in Enumerator.new.
    cols = 0
    words.slice_before { |w|
      cols += 1 if cols != 0
      cols += w.length
      if maxwidth &lt; cols
        cols = w.length
        true
      else
        false
      end
    }.each {|ws| y.yield ws }
  }
end
text = (1..20).to_a.join(&quot; &quot;)
enum = wordwrap(text.split(/\s+/), 10)
puts &quot;-&quot;*10
enum.each { |ws| puts ws.join(&quot; &quot;) } # first enumeration.
puts &quot;-&quot;*10
enum.each { |ws| puts ws.join(&quot; &quot;) } # second enumeration generates same result as the first.
puts &quot;-&quot;*10
#=&gt; ----------
#   1 2 3 4 5
#   6 7 8 9 10
#   11 12 13
#   14 15 16
#   17 18 19
#   20
#   ----------
#   1 2 3 4 5
#   6 7 8 9 10
#   11 12 13
#   14 15 16
#   17 18 19
#   20
#   ----------
</code></pre>

<p>mbox contains series of mails which start with Unix From line. So each mail
can be extracted by slice before Unix From line.</p>

<pre><code># parse mbox
open(&quot;mbox&quot;) { |f|
  f.slice_before { |line|
    line.start_with? &quot;From &quot;
  }.each { |mail|
    unix_from = mail.shift
    i = mail.index(&quot;\n&quot;)
    header = mail[0...i]
    body = mail[(i+1)..-1]
    body.pop if body.last == &quot;\n&quot;
    fields = header.slice_before { |line| !&quot; \t&quot;.include?(line[0]) }.to_a
    p unix_from
    pp fields
    pp body
  }
}

# split mails in mbox (slice before Unix From line after an empty line)
open(&quot;mbox&quot;) { |f|
  f.slice_before(emp: true) { |line, h|
    prevemp = h[:emp]
    h[:emp] = line == &quot;\n&quot;
    prevemp &amp;&amp; line.start_with?(&quot;From &quot;)
  }.each { |mail|
    mail.pop if mail.last == &quot;\n&quot;
    pp mail
  }
}
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-slice_before_source')" id="l_method-i-slice_before_source">show</a>
                
              </p>
              <div id="method-i-slice_before_source" class="dyn-source">
                <pre>static VALUE
enum_slice_before(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;

    if (rb_block_given_p()) {
        if (argc != 0)
            rb_error_arity(argc, 0, 0);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_sep_pred&quot;), rb_block_proc());
    }
    else {
        VALUE sep_pat;
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;sep_pat);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_sep_pat&quot;), sep_pat);
    }
    rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_enumerable&quot;), enumerable);
    rb_block_call(enumerator, idInitialize, 0, 0, slicebefore_i, enumerator);
    return enumerator;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-slice_when">
            
              <b>enum.slice_when {|elt_before, elt_after| bool } &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-slice_when" name="method-i-slice_when" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Creates an enumerator for each chunked elements. The beginnings of chunks
are defined by the block.</p>

<p>This method split each chunk using adjacent elements, <em>elt_before</em>
and <em>elt_after</em>, in the receiver enumerator. This method split
chunks between <em>elt_before</em> and <em>elt_after</em> where the block
returns true.</p>

<p>The block is called the length of the receiver enumerator minus one.</p>

<p>The result enumerator yields the chunked elements as an array. So
<code>each</code> method can be called as follows:</p>

<pre><code>enum.slice_when { |elt_before, elt_after| bool }.each { |ary| ... }</code></pre>

<p>Other methods of the <a href="Enumerator.html">Enumerator</a> class and <a
href="Enumerable.html">Enumerable</a> module, such as <code>to_a</code>,
<code>map</code>, etc., are also usable.</p>

<p>For example, one-by-one increasing subsequence can be chunked as follows:</p>

<pre><code>a = [1,2,4,9,10,11,12,15,16,19,20,21]
b = a.slice_when {|i, j| i+1 != j }
p b.to_a #=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
c = b.map {|a| a.length &lt; 3 ? a : &quot;#{a.first}-#{a.last}&quot; }
p c #=&gt; [[1, 2], [4], &quot;9-12&quot;, [15, 16], &quot;19-21&quot;]
d = c.join(&quot;,&quot;)
p d #=&gt; &quot;1,2,4,9-12,15,16,19-21&quot;
</code></pre>

<p>Near elements (threshold: 6) in sorted array can be chunked as follows:</p>

<pre><code>a = [3, 11, 14, 25, 28, 29, 29, 41, 55, 57]
p a.slice_when {|i, j| 6 &lt; j - i }.to_a
#=&gt; [[3], [11, 14], [25, 28, 29, 29], [41], [55, 57]]
</code></pre>

<p>Increasing (non-decreasing) subsequence can be chunked as follows:</p>

<pre><code>a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]
p a.slice_when {|i, j| i &gt; j }.to_a
#=&gt; [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]
</code></pre>

<p>Adjacent evens and odds can be chunked as follows: (Enumerable#chunk is
another way to do it.)</p>

<pre><code>a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]
p a.slice_when {|i, j| i.even? != j.even? }.to_a
#=&gt; [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]
</code></pre>

<p>Paragraphs (non-empty lines with trailing empty lines) can be chunked as
follows: (See <a href="Enumerable.html#method-i-chunk">#chunk</a> to ignore
empty lines.)</p>

<pre><code>lines = [&quot;foo\n&quot;, &quot;bar\n&quot;, &quot;\n&quot;, &quot;baz\n&quot;, &quot;qux\n&quot;]
p lines.slice_when {|l1, l2| /\A\s*\z/ =~ l1 &amp;&amp; /\S/ =~ l2 }.to_a
#=&gt; [[&quot;foo\n&quot;, &quot;bar\n&quot;, &quot;\n&quot;], [&quot;baz\n&quot;, &quot;qux\n&quot;]]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-slice_when_source')" id="l_method-i-slice_when_source">show</a>
                
              </p>
              <div id="method-i-slice_when_source" class="dyn-source">
                <pre>static VALUE
enum_slice_when(VALUE enumerable)
{
    VALUE enumerator;
    VALUE pred;

    pred = rb_block_proc();

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_enum&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_pred&quot;), pred);
    rb_ivar_set(enumerator, rb_intern(&quot;slicewhen_inverted&quot;), Qfalse);

    rb_block_call(enumerator, idInitialize, 0, 0, slicewhen_i, enumerator);
    return enumerator;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-sort">
            
              <b>enum.sort                  &rarr; array
enum.sort { |a, b| block } &rarr; array
</b>
            
            <a href="../classes/Enumerable.html#method-i-sort" name="method-i-sort" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns an array containing the items in <em>enum</em> sorted, either
according to their own <code>&lt;=&gt;</code> method, or by using the
results of the supplied block. The block should return -1, 0, or +1
depending on the comparison between <em>a</em> and <em>b</em>. As of Ruby
1.8, the method <code>Enumerable#sort_by</code> implements a built-in
Schwartzian Transform, useful when key computation or comparison is
expensive.</p>

<pre><code>%w(rhea kea flea).sort          #=&gt; [&quot;flea&quot;, &quot;kea&quot;, &quot;rhea&quot;]
(1..10).sort { |a, b| b &lt;=&gt; a }  #=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-sort_source')" id="l_method-i-sort_source">show</a>
                
              </p>
              <div id="method-i-sort_source" class="dyn-source">
                <pre>static VALUE
enum_sort(VALUE obj)
{
    return rb_ary_sort(enum_to_a(0, 0, obj));
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-sort_by">
            
              <b>enum.sort_by { |obj| block }   &rarr; array
enum.sort_by                   &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-sort_by" name="method-i-sort_by" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Sorts <em>enum</em> using a set of keys generated by mapping the values in
<em>enum</em> through the given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>%w{apple pear fig}.sort_by { |word| word.length}
              #=&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]
</code></pre>

<p>The current implementation of <code>sort_by</code> generates an array of
tuples containing the original collection element and the mapped value.
This makes <code>sort_by</code> fairly expensive when the keysets are
simple.</p>

<pre><code>require &#39;benchmark&#39;

a = (1..100000).map { rand(100000) }

Benchmark.bm(10) do |b|
  b.report(&quot;Sort&quot;)    { a.sort }
  b.report(&quot;Sort by&quot;) { a.sort_by { |a| a } }
end
</code></pre>

<p><em>produces:</em></p>

<pre><code>user     system      total        real
Sort        0.180000   0.000000   0.180000 (  0.175469)
Sort by     1.980000   0.040000   2.020000 (  2.013586)</code></pre>

<p>However, consider the case where comparing the keys is a non-trivial
operation. The following code sorts some files on modification time using
the basic <code>sort</code> method.</p>

<pre><code>files = Dir[&quot;*&quot;]
sorted = files.sort { |a, b| File.new(a).mtime &lt;=&gt; File.new(b).mtime }
sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
</code></pre>

<p>This sort is inefficient: it generates two new <code>File</code> objects
during every comparison. A slightly better technique is to use the
<code>Kernel#test</code> method to generate the modification times
directly.</p>

<pre><code>files = Dir[&quot;*&quot;]
sorted = files.sort { |a, b|
  test(?M, a) &lt;=&gt; test(?M, b)
}
sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
</code></pre>

<p>This still generates many unnecessary <code>Time</code> objects. A more
efficient technique is to cache the sort keys (modification times in this
case) before the sort. Perl users often call this approach a Schwartzian
Transform, after Randal Schwartz. We construct a temporary array, where
each element is an array containing our sort key along with the filename.
We sort this array, and then extract the filename from the result.</p>

<pre><code>sorted = Dir[&quot;*&quot;].collect { |f|
   [test(?M, f), f]
}.sort.collect { |f| f[1] }
sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
</code></pre>

<p>This is exactly what <code>sort_by</code> does internally.</p>

<pre><code>sorted = Dir[&quot;*&quot;].sort_by { |f| test(?M, f) }
sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-sort_by_source')" id="l_method-i-sort_by_source">show</a>
                
              </p>
              <div id="method-i-sort_by_source" class="dyn-source">
                <pre>static VALUE
enum_sort_by(VALUE obj)
{
    VALUE ary, buf;
    struct MEMO *memo;
    long i;
    struct sort_by_data *data;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    if (RB_TYPE_P(obj, T_ARRAY) &amp;&amp; RARRAY_LEN(obj) &lt;= LONG_MAX/2) {
        ary = rb_ary_new2(RARRAY_LEN(obj)*2);
    }
    else {
        ary = rb_ary_new();
    }
    RBASIC_CLEAR_CLASS(ary);
    buf = rb_ary_tmp_new(SORT_BY_BUFSIZE*2);
    rb_ary_store(buf, SORT_BY_BUFSIZE*2-1, Qnil);
    memo = MEMO_NEW(0, 0, 0);
    OBJ_INFECT(memo, obj);
    data = (struct sort_by_data *)&amp;memo-&gt;v1;
    RB_OBJ_WRITE(memo, &amp;data-&gt;ary, ary);
    RB_OBJ_WRITE(memo, &amp;data-&gt;buf, buf);
    data-&gt;n = 0;
    rb_block_call(obj, id_each, 0, 0, sort_by_i, (VALUE)memo);
    ary = data-&gt;ary;
    buf = data-&gt;buf;
    if (data-&gt;n) {
        rb_ary_resize(buf, data-&gt;n*2);
        rb_ary_concat(ary, buf);
    }
    if (RARRAY_LEN(ary) &gt; 2) {
        RARRAY_PTR_USE(ary, ptr,
                      ruby_qsort(ptr, RARRAY_LEN(ary)/2, 2*sizeof(VALUE),
                                 sort_by_cmp, (void *)ary));
    }
    if (RBASIC(ary)-&gt;klass) {
        rb_raise(rb_eRuntimeError, &quot;sort_by reentered&quot;);
    }
    for (i=1; i&lt;RARRAY_LEN(ary); i+=2) {
        RARRAY_ASET(ary, i/2, RARRAY_AREF(ary, i));
    }
    rb_ary_resize(ary, RARRAY_LEN(ary)/2);
    RBASIC_SET_CLASS_RAW(ary, rb_cArray);
    OBJ_INFECT(ary, memo);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-take">
            
              <b>enum.take(n)               &rarr; array
</b>
            
            <a href="../classes/Enumerable.html#method-i-take" name="method-i-take" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns first n elements from <em>enum</em>.</p>

<pre><code>a = [1, 2, 3, 4, 5, 0]
a.take(3)             #=&gt; [1, 2, 3]
a.take(30)            #=&gt; [1, 2, 3, 4, 5, 0]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-take_source')" id="l_method-i-take_source">show</a>
                
              </p>
              <div id="method-i-take_source" class="dyn-source">
                <pre>static VALUE
enum_take(VALUE obj, VALUE n)
{
    struct MEMO *memo;
    VALUE result;
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }

    if (len == 0) return rb_ary_new2(0);
    result = rb_ary_new2(len);
    memo = MEMO_NEW(result, 0, len);
    rb_block_call(obj, id_each, 0, 0, take_i, (VALUE)memo);
    return result;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-take_while">
            
              <b>enum.take_while { |arr| block } &rarr; array
enum.take_while                 &rarr; an_enumerator
</b>
            
            <a href="../classes/Enumerable.html#method-i-take_while" name="method-i-take_while" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Passes elements to the block until the block returns <code>nil</code> or
<code>false</code>, then stops iterating and returns an array of all prior
elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre><code>a = [1, 2, 3, 4, 5, 0]
a.take_while { |i| i &lt; 3 }   #=&gt; [1, 2]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-take_while_source')" id="l_method-i-take_while_source">show</a>
                
              </p>
              <div id="method-i-take_while_source" class="dyn-source">
                <pre>static VALUE
enum_take_while(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);
    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, take_while_i, ary);
    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-to_a">
            
              <b>enum.to_a(*args)      &rarr; array</b>
            
            <a href="../classes/Enumerable.html#method-i-to_a" name="method-i-to_a" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns an array containing the items in <em>enum</em>.</p>

<pre><code>(1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
{ &#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2, &#39;c&#39;=&gt;3 }.to_a   #=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]

require &#39;prime&#39;
Prime.entries 10                  #=&gt; [2, 3, 5, 7]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-to_a_source')" id="l_method-i-to_a_source">show</a>
                
              </p>
              <div id="method-i-to_a_source" class="dyn-source">
                <pre>static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);
    OBJ_INFECT(ary, obj);

    return ary;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-to_h">
            
              <b>enum.to_h(*args)  &rarr; hash
</b>
            
            <a href="../classes/Enumerable.html#method-i-to_h" name="method-i-to_h" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Returns the result of interpreting <em>enum</em> as a list of <code>[key,
value]</code> pairs.</p>

<pre><code>%i[hello world].each_with_index.to_h
  # =&gt; {:hello =&gt; 0, :world =&gt; 1}
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-to_h_source')" id="l_method-i-to_h_source">show</a>
                
              </p>
              <div id="method-i-to_h_source" class="dyn-source">
                <pre>static VALUE
enum_to_h(int argc, VALUE *argv, VALUE obj)
{
    VALUE hash = rb_hash_new();
    rb_block_call(obj, id_each, argc, argv, enum_to_h_i, hash);
    OBJ_INFECT(hash, obj);
    return hash;
}</pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-to_set">
            
              <b>to_set</b>(klass = Set, *args, &amp;block)
            
            <a href="../classes/Enumerable.html#method-i-to_set" name="method-i-to_set" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Makes a set from the enumerable object with given arguments. Needs to
+require “set”+ to use this method.</p>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-to_set_source')" id="l_method-i-to_set_source">show</a>
                
              </p>
              <div id="method-i-to_set_source" class="dyn-source">
                <pre><span class="ruby-comment"># File lib/set.rb, line 702</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword ruby-title">to_set</span>(<span class="ruby-identifier">klass</span> = <span class="ruby-constant">Set</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></pre>
              </div>
            </div>
            
          </div>
        
        <div class="method">
          <div class="title method-title" id="method-i-zip">
            
              <b>enum.zip(arg, ...)                  &rarr; an_array_of_array
enum.zip(arg, ...) { |arr| block }  &rarr; nil
</b>
            
            <a href="../classes/Enumerable.html#method-i-zip" name="method-i-zip" class="permalink">Link</a>
          </div>
          
          
            <div class="description">
              <p>Takes one element from <em>enum</em> and merges corresponding elements from
each <em>args</em>.  This generates a sequence of <em>n</em>-element
arrays, where <em>n</em> is one more than the count of arguments.  The
length of the resulting sequence will be <code>enum#size</code>.  If the
size of any argument is less than <code>enum#size</code>, <code>nil</code>
values are supplied. If a block is given, it is invoked for each output
array, otherwise an array of arrays is returned.</p>

<pre><code>a = [ 4, 5, 6 ]
b = [ 7, 8, 9 ]

a.zip(b)                 #=&gt; [[4, 7], [5, 8], [6, 9]]
[1, 2, 3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
[1, 2].zip(a, b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
a.zip([1, 2], [8])       #=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]

c = []
a.zip(b) { |x, y| c &lt;&lt; x + y }  #=&gt; nil
c                               #=&gt; [11, 13, 15]
</code></pre>
            </div>
          
          
          

          
          
          
            
            <div class="sourcecode">
              
              <p class="source-link">
                Source: 
                <a href="javascript:toggleSource('method-i-zip_source')" id="l_method-i-zip_source">show</a>
                
              </p>
              <div id="method-i-zip_source" class="dyn-source">
                <pre>static VALUE
enum_zip(int argc, VALUE *argv, VALUE obj)
{
    int i;
    ID conv;
    struct MEMO *memo;
    VALUE result = Qnil;
    VALUE args = rb_ary_new4(argc, argv);
    int allary = TRUE;

    argv = RARRAY_PTR(args);
    for (i=0; i&lt;argc; i++) {
        VALUE ary = rb_check_array_type(argv[i]);
        if (NIL_P(ary)) {
            allary = FALSE;
            break;
        }
        argv[i] = ary;
    }
    if (!allary) {
        CONST_ID(conv, &quot;to_enum&quot;);
        for (i=0; i&lt;argc; i++) {
            if (!rb_respond_to(argv[i], id_each)) {
                rb_raise(rb_eTypeError, &quot;wrong argument type %&quot;PRIsVALUE&quot; (must respond to :each)&quot;,
                         rb_obj_class(argv[i]));
            }
            argv[i] = rb_funcall(argv[i], conv, 1, ID2SYM(id_each));
        }
    }
    if (!rb_block_given_p()) {
        result = rb_ary_new();
    }

    /* TODO: use NODE_DOT2 as memo(v, v, -) */
    memo = MEMO_NEW(result, args, 0);
    rb_block_call(obj, id_each, 0, 0, allary ? zip_ary : zip_i, (VALUE)memo);

    return result;
}</pre>
              </div>
            </div>
            
          </div>
                    </div>

    </div>
  </body>
</html>    